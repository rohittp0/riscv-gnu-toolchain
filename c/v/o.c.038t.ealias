
;; Function vector_add (vector_add, funcdef_no=0, decl_uid=1454, cgraph_uid=1, symbol_order=0)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
a = &NONLOCAL
b = &NONLOCAL
i.0_1 = i_13
_2 = i.0_1 + UNKNOWN
_2 = &NONLOCAL
_3 = a + UNKNOWN
_4 = *_3
i.1_5 = i_13
_6 = i.1_5 + UNKNOWN
_6 = &NONLOCAL
_7 = b + UNKNOWN
_8 = *_7
i.2_9 = i_13
_10 = i.2_9 + UNKNOWN
_10 = &NONLOCAL
_11 = a + UNKNOWN
_12 = _4 + UNKNOWN
_12 = _8 + UNKNOWN
*_11 = _12
i_20 = i_13 + UNKNOWN
i_20 = &NONLOCAL
i_13 = &NULL
i_13 = i_20

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
a = { NONLOCAL }
b = { NONLOCAL } same as a
i.0_1 = { NULL NONLOCAL }
i_13 = { NULL NONLOCAL } same as i.0_1
_2 = { NULL NONLOCAL }
_3 = { NONLOCAL }
_4 = { ESCAPED NONLOCAL }
i.1_5 = { NULL NONLOCAL } same as i.0_1
_6 = { NULL NONLOCAL }
_7 = { NONLOCAL }
_8 = { ESCAPED NONLOCAL }
i.2_9 = { NULL NONLOCAL } same as i.0_1
_10 = { NULL NONLOCAL }
_11 = { NONLOCAL }
_12 = { ESCAPED NONLOCAL }
i_20 = { NULL NONLOCAL }


Alias information for vector_add

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_3, points-to non-local, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to NULL, points-to vars: { }
a_17(D), points-to non-local, points-to NULL, points-to vars: { }
b_18(D), points-to non-local, points-to NULL, points-to vars: { }

void vector_add (int * a, int * b)
{
  int i;
  unsigned int i.0_1;
  unsigned int _2;
  int * _3;
  int _4;
  unsigned int i.1_5;
  unsigned int _6;
  int * _7;
  int _8;
  unsigned int i.2_9;
  unsigned int _10;
  int * _11;
  int _12;

  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  i.0_1 = (unsigned int) i_13;
  _2 = i.0_1 * 4;
  _3 = a_17(D) + _2;
  _4 = *_3;
  i.1_5 = (unsigned int) i_13;
  _6 = i.1_5 * 4;
  _7 = b_18(D) + _6;
  _8 = *_7;
  i.2_9 = (unsigned int) i_13;
  _10 = i.2_9 * 4;
  _11 = a_17(D) + _10;
  _12 = _4 + _8;
  *_11 = _12;
  i_20 = i_13 + 1;

  <bb 4> :
  # i_13 = PHI <0(2), i_20(3)>
  if (i_13 <= 3)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}


